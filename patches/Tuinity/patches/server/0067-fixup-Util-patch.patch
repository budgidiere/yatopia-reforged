From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <spottedleaf@spottedleaf.dev>
Date: Sat, 7 Nov 2020 19:51:55 -0800
Subject: [PATCH] fixup! Util patch


diff --git a/src/main/java/com/tuinity/tuinity/chunk/SingleThreadChunkRegionManager.java b/src/main/java/com/tuinity/tuinity/chunk/SingleThreadChunkRegionManager.java
index 4cb10fe69cc672d2178de3c5b689cf29d1f1265e..cae06962d80cdd00962236891472ba815b0ab8cd 100644
--- a/src/main/java/com/tuinity/tuinity/chunk/SingleThreadChunkRegionManager.java
+++ b/src/main/java/com/tuinity/tuinity/chunk/SingleThreadChunkRegionManager.java
@@ -10,18 +10,18 @@ import net.minecraft.server.ChunkCoordIntPair;
 import net.minecraft.server.MCUtil;
 import net.minecraft.server.WorldServer;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.EnumMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.function.Function;
-import java.util.function.LongFunction;
 
 public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThreadChunkRegionManager.RegionDataCreator<T>> {
 
     static final int REGION_SECTION_MERGE_RADIUS = 1;
     // if this becomes > 8, then the RegionSection needs to be properly modified (see bitset)
-    public static final int REGION_CHUNK_SIZE = 8;
-    public static final int REGION_CHUNK_SIZE_SHIFT = 3; // log2(REGION_CHUNK_SIZE)
+    public static final int REGION_CHUNK_SIZE = 32;
+    public static final int REGION_CHUNK_SIZE_SHIFT = 5; // log2(REGION_CHUNK_SIZE)
 
     public final WorldServer world;
     public final Class<T> dataClass;
@@ -51,6 +51,23 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
         this.regionRecalculateTimings = MinecraftTimings.getInternalTaskName(prefix.concat("recalculate"));
     }
 
+    // tested via https://gist.github.com/Spottedleaf/aa7ade3451c37b4cac061fc77074db2f
+
+    /*
+    protected void check() {
+        ReferenceOpenHashSet<Region<T>> checked = new ReferenceOpenHashSet<>();
+
+        for (RegionSection<T> section : this.regionsBySection.values()) {
+            if (!checked.add(section.region)) {
+                section.region.check();
+            }
+        }
+        for (Region<T> region : this.needsRecalculation) {
+            region.check();
+        }
+    }
+    */
+
     protected void addToRecalcQueue(final Region<T> region) {
         this.needsRecalculation.add(region);
     }
@@ -69,20 +86,26 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
     }
 
     private final List<Region<T>> toMerge = new ArrayList<>((2 * REGION_SECTION_MERGE_RADIUS + 1) * (2 * REGION_SECTION_MERGE_RADIUS + 1));
-    protected final LongFunction<RegionSection<T>> createRegionIfAbsent = (final long keyInMap) -> {
-        return new RegionSection<>(keyInMap, SingleThreadChunkRegionManager.this);
-    };
 
     protected RegionSection<T> getOrCreateAndMergeSection(final int sectionX, final int sectionZ, final RegionSection<T> force) {
+        final long sectionKey = MCUtil.getCoordinateKey(sectionX, sectionZ);
+
+        if (force == null) {
+            RegionSection<T> region = this.regionsBySection.get(sectionKey);
+            if (region != null) {
+                return region;
+            }
+        }
+
+        int mergeCandidateSectionSize = -1;
+        Region<T> mergeIntoCandidate = null;
+
         // find optimal candidate to merge into
+
         final int minX = sectionX - REGION_SECTION_MERGE_RADIUS;
         final int maxX = sectionX + REGION_SECTION_MERGE_RADIUS;
         final int minZ = sectionZ - REGION_SECTION_MERGE_RADIUS;
         final int maxZ = sectionZ + REGION_SECTION_MERGE_RADIUS;
-
-        int mergeCandidateSectionSize = -1;
-        Region<T> mergeIntoCandidate = null;
-
         for (int currX = minX; currX <= maxX; ++currX) {
             for (int currZ = minZ; currZ <= maxZ; ++currZ) {
                 final RegionSection<T> section = this.regionsBySection.get(MCUtil.getCoordinateKey(currX, currZ));
@@ -105,21 +128,21 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
 
         // merge
         if (mergeIntoCandidate != null) {
-            for (int len = this.toMerge.size(), i = len - 1; i >= 0; --i) {
-                final Region<T> region = this.toMerge.remove(i);
+            for (int i = 0; i < this.toMerge.size(); ++i) {
+                final Region<T> region = this.toMerge.get(i);
                 if (region.dead || mergeIntoCandidate == region) {
                     continue;
                 }
                 region.mergeInto(mergeIntoCandidate);
             }
+            this.toMerge.clear();
         } else {
             mergeIntoCandidate = new Region<>(this);
         }
 
-        final long sectionKey = MCUtil.getCoordinateKey(sectionX, sectionZ);
         final RegionSection<T> section;
         if (force == null) {
-            section = this.regionsBySection.computeIfAbsent(sectionKey, this.createRegionIfAbsent);
+            this.regionsBySection.put(sectionKey, section = new RegionSection<>(sectionKey, this));
         } else {
             final RegionSection<T> existing = this.regionsBySection.putIfAbsent(sectionKey, force);
             if (existing != null) {
@@ -132,6 +155,8 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
 
         section.region = mergeIntoCandidate;
         mergeIntoCandidate.sections.add(section);
+        //mergeIntoCandidate.check();
+        //this.check();
 
         return section;
     }
@@ -151,7 +176,8 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
         this.removeChunkTimings.startTiming();
         try {
             final RegionSection<T> section = this.regionsBySection.get(
-                    MCUtil.getCoordinateKey(chunkX >> REGION_CHUNK_SIZE_SHIFT, chunkZ >> REGION_CHUNK_SIZE_SHIFT));
+                    MCUtil.getCoordinateKey(chunkX >> REGION_CHUNK_SIZE_SHIFT, chunkZ >> REGION_CHUNK_SIZE_SHIFT)
+            );
             if (section != null) {
                 section.removeChunk(chunkX, chunkZ);
             } else {
@@ -168,6 +194,7 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
             final Region<T> region = this.needsRecalculation.removeFirst();
 
             this.recalculateRegion(region);
+            //this.check();
         }
     }
 
@@ -175,23 +202,28 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
         this.regionRecalculateTimings.startTiming();
         try {
             region.markedForRecalc = false;
+            //region.check();
             // clear unused regions
-            for (final Iterator<RegionSection<T>> iterator = region.deadSections.iterator(); iterator.hasNext(); ) {
+            for (final Iterator<RegionSection<T>> iterator = region.deadSections.iterator(); iterator.hasNext();) {
                 final RegionSection<T> deadSection = iterator.next();
+
+                if (deadSection.hasChunks()) {
+                    throw new IllegalStateException("Dead section '" + deadSection.toStringWithRegion() + "' is marked dead but has chunks!");
+                }
+                if (!region.sections.remove(deadSection)) {
+                    throw new IllegalStateException("Region " + region + " has inconsistent state, it should contain section " + deadSection);
+                }
                 if (!this.regionsBySection.remove(deadSection.regionCoordinate, deadSection)) {
                     throw new IllegalStateException("Cannot remove dead section '" +
                             deadSection.toStringWithRegion() + "' from section state! State at section coordinate: " +
                             this.regionsBySection.get(deadSection.regionCoordinate));
                 }
-                if (!region.sections.remove(deadSection)) {
-                    throw new IllegalStateException("Region " + region + " has inconsistent state, it should contain section " + deadSection);
-                }
-
-                iterator.remove();
             }
+            region.deadSections.clear();
 
             // implicitly cover cases where size == 0
             if (region.sections.size() < this.minSectionRecalcCount) {
+                //region.check();
                 return;
             }
 
@@ -204,6 +236,9 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
             // destroy region state
             for (final Iterator<RegionSection<T>> iterator = region.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
                 final RegionSection<T> aliveSection = iterator.next();
+                if (!aliveSection.hasChunks()) {
+                    throw new IllegalStateException("Alive section '" + aliveSection.toStringWithRegion() + "' has no chunks!");
+                }
                 if (!this.regionsBySection.remove(aliveSection.regionCoordinate, aliveSection)) {
                     throw new IllegalStateException("Cannot remove alive section '" +
                             aliveSection.toStringWithRegion() + "' from section state! State at section coordinate: " +
@@ -241,13 +276,36 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
             return (double)this.deadSections.size() / (double)this.sections.size();
         }
 
+        /*
+        protected void check() {
+            if (this.dead) {
+                throw new IllegalStateException("Dead region!");
+            }
+            for (final Iterator<RegionSection<T>> iterator = this.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                final RegionSection<T> section = iterator.next();
+                if (section.region != this) {
+                    throw new IllegalStateException("Region section must point to us!");
+                }
+                if (this.regionManager.regionsBySection.get(section.regionCoordinate) != section) {
+                    throw new IllegalStateException("Region section must match the regionmanager state!");
+                }
+            }
+        }
+        */
+
         protected void mergeInto(final Region<T> mergeTarget) {
+            if (this == mergeTarget) {
+                throw new IllegalStateException("Cannot merge a region onto itself");
+            }
             if (this.dead) {
                 throw new IllegalStateException("Source region is dead! Source " + this + ", target " + mergeTarget);
             } else if (mergeTarget.dead) {
                 throw new IllegalStateException("Target region is dead! Source " + this + ", target " + mergeTarget);
             }
             this.dead = true;
+            if (this.markedForRecalc) {
+                this.regionManager.removeFromRecalcQueue(this);
+            }
 
             for (final Iterator<RegionSection<T>> iterator = this.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
                 final RegionSection<T> section = iterator.next();
@@ -265,6 +323,7 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
                 }
                 mergeTarget.deadSections.add(deadSection);
             }
+            //mergeTarget.check();
         }
 
         protected void markSectionAlive(final RegionSection<T> section) {
@@ -309,7 +368,8 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
 
     public static final class RegionSection<T extends Enum<T> & SingleThreadChunkRegionManager.RegionDataCreator<T>> {
         protected final long regionCoordinate;
-        protected long chunksBitset;
+        protected final long[] chunksBitset = new long[Math.max(1, REGION_CHUNK_SIZE * REGION_CHUNK_SIZE / Long.SIZE)];
+        protected int chunkCount;
         protected Region<T> region;
         protected final EnumMap<T, Object> data;
         protected final Function<? super T, Object> createIfAbsentFunction;
@@ -357,25 +417,31 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
             return (chunkX & (REGION_CHUNK_SIZE - 1)) | ((chunkZ & (REGION_CHUNK_SIZE - 1)) << REGION_CHUNK_SIZE_SHIFT);
         }
 
+        protected boolean hasChunks() {
+            return this.chunkCount != 0;
+        }
+
         protected void addChunk(final int chunkX, final int chunkZ) {
-            final long bitset = this.chunksBitset;
-            final long after = this.chunksBitset = bitset | (1L << getChunkIndex(chunkX, chunkZ));
+            final int index = getChunkIndex(chunkX, chunkZ);
+            final long bitset = this.chunksBitset[index >>> 6]; // index / Long.SIZE
+            final long after = this.chunksBitset[index >>> 6] = bitset | (1L << (index & (Long.SIZE - 1)));
             if (after == bitset) {
                 throw new IllegalStateException("Cannot add a chunk to a section which already has the chunk! RegionSection: " + this + ", global chunk: " + new ChunkCoordIntPair(chunkX, chunkZ).toString());
             }
-            if (bitset != 0L) {
+            if (++this.chunkCount != 1) {
                 return;
             }
             this.region.markSectionAlive(this);
         }
 
         protected void removeChunk(final int chunkX, final int chunkZ) {
-            final long before = this.chunksBitset;
-            final long bitset = this.chunksBitset = before & ~(1L << getChunkIndex(chunkX, chunkZ));
+            final int index = getChunkIndex(chunkX, chunkZ);
+            final long before = this.chunksBitset[index >>> 6]; // index / Long.SIZE
+            final long bitset = this.chunksBitset[index >>> 6] = before & ~(1L << (index & (Long.SIZE - 1)));
             if (before == bitset) {
                 throw new IllegalStateException("Cannot remove a chunk from a section which does not have that chunk! RegionSection: " + this + ", global chunk: " + new ChunkCoordIntPair(chunkX, chunkZ).toString());
             }
-            if (bitset != 0L) {
+            if (--this.chunkCount != 0) {
                 return;
             }
             this.region.markSectionDead(this);
@@ -385,19 +451,36 @@ public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThre
         public String toString() {
             return "RegionSection{" +
                     "regionCoordinate=" + new ChunkCoordIntPair(this.regionCoordinate).toString() + "," +
-                    "chunksBitset=" + Long.toHexString(this.chunksBitset) + "," +
-                    "hash=" + this.hashCode() + "," +
+                    "chunkCount=" + this.chunkCount + "," +
+                    "chunksBitset=" + toString(this.chunksBitset) + "," +
+                    "hash=" + this.hashCode() +
                     "}";
         }
 
         public String toStringWithRegion() {
             return "RegionSection{" +
                     "regionCoordinate=" + new ChunkCoordIntPair(this.regionCoordinate).toString() + "," +
-                    "chunksBitset=" + Long.toHexString(this.chunksBitset) + "," +
+                    "chunkCount=" + this.chunkCount + "," +
+                    "chunksBitset=" + toString(this.chunksBitset) + "," +
                     "hash=" + this.hashCode() + "," +
-                    "region=" + this.region + "," +
+                    "region=" + this.region +
                     "}";
         }
+
+        private static String toString(final long[] array) {
+            StringBuilder ret = new StringBuilder();
+            for (long value : array) {
+                // zero pad the hex string
+                char[] zeros = new char[Long.SIZE / 4];
+                Arrays.fill(zeros, '0');
+                String string = Long.toHexString(value);
+                System.arraycopy(string.toCharArray(), 0, zeros, zeros.length - string.length(), string.length());
+
+                ret.append(zeros);
+            }
+
+            return ret.toString();
+        }
     }
 
     public static interface RegionDataCreator<E extends Enum<E> & RegionDataCreator<E>> {
diff --git a/src/main/java/com/tuinity/tuinity/util/maplist/IteratorSafeOrderedReferenceSet.java b/src/main/java/com/tuinity/tuinity/util/maplist/IteratorSafeOrderedReferenceSet.java
index 6d2851ffa32e299dc7588e29ad5076253786080e..be408aebbccbda46e8aa82ef337574137cfa0096 100644
--- a/src/main/java/com/tuinity/tuinity/util/maplist/IteratorSafeOrderedReferenceSet.java
+++ b/src/main/java/com/tuinity/tuinity/util/maplist/IteratorSafeOrderedReferenceSet.java
@@ -2,6 +2,7 @@ package com.tuinity.tuinity.util.maplist;
 
 import it.unimi.dsi.fastutil.objects.Reference2IntLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import org.bukkit.Bukkit;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
@@ -44,6 +45,48 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         this.threadRestricted = threadRestricted;
     }
 
+    /*
+    public void check() {
+        int iterated = 0;
+        ReferenceOpenHashSet<E> check = new ReferenceOpenHashSet<>();
+        if (this.listElements != null) {
+            for (int i = 0; i < this.listSize; ++i) {
+                Object obj = this.listElements[i];
+                if (obj != null) {
+                    iterated++;
+                    if (!check.add((E)obj)) {
+                        throw new IllegalStateException("contains duplicate");
+                    }
+                    if (!this.contains((E)obj)) {
+                        throw new IllegalStateException("desync");
+                    }
+                }
+            }
+        }
+
+        if (iterated != this.size()) {
+            throw new IllegalStateException("Size is mismatched! Got " + iterated + ", expected " + this.size());
+        }
+
+        check.clear();
+        iterated = 0;
+        for (final java.util.Iterator<E> iterator = this.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+            final E element = iterator.next();
+            iterated++;
+            if (!check.add(element)) {
+                throw new IllegalStateException("contains duplicate (iterator is wrong)");
+            }
+            if (!this.contains(element)) {
+                throw new IllegalStateException("desync (iterator is wrong)");
+            }
+        }
+
+        if (iterated != this.size()) {
+            throw new IllegalStateException("Size is mismatched! (iterator is wrong) Got " + iterated + ", expected " + this.size());
+        }
+    }
+    */
+
     protected final boolean allowSafeIteration() {
         return !this.threadRestricted || Bukkit.isPrimaryThread();
     }
@@ -96,6 +139,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
             if (this.allowSafeIteration() && this.iteratorCount == 0 && this.getFragFactor() >= this.maxFragFactor) {
                 this.defrag();
             }
+            //this.check();
             return true;
         }
         return false;
@@ -119,6 +163,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         this.listElements[listSize] = element;
         this.listSize = listSize + 1;
 
+        //this.check();
         return true;
     }
 
@@ -131,6 +176,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
             Arrays.fill(this.listElements, 0, this.listSize, null);
             this.listSize = 0;
             this.firstInvalidIndex = -1;
+            //this.check();
             return;
         }
 
@@ -175,6 +221,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         Arrays.fill(backingArray, lastValidIndex, this.listSize, null);
         this.listSize = lastValidIndex;
         this.firstInvalidIndex = -1;
+        //this.check();
     }
 
     public E rawGet(final int index) {
