From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <spottedleaf@spottedleaf.dev>
Date: Fri, 6 Nov 2020 02:51:39 -0800
Subject: [PATCH] fixup! Highly optimise single and multi-AABB VoxelShapes and
 collisions


diff --git a/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java b/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java
index b321ad51635949d07b9b818f2940a31bca1a74e3..002abb3cbf0f742e685f2f043d2600de03e37a19 100644
--- a/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java
+++ b/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java
@@ -143,6 +143,9 @@ public final class AABBVoxelShape extends VoxelShape {
 
     @Override
     public double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, double d0) { // collide
+        if (this.aabb.isEmpty() || axisalignedbb.isEmpty()) {
+            return d0;
+        }
         switch (enumdirection_enumaxis.ordinal()) {
             case 0:
                 return AxisAlignedBB.collideX(this.aabb, axisalignedbb, d0);
diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index acd009844099293befd28c5f1c20d947016fa19b..fd3bb6dfa6cc060e9785c22a9e61a4325c348e36 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -54,9 +54,6 @@ public class AxisAlignedBB {
     }
 
     public static double collideX(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
-        if (target.isEmpty() || source.isEmpty()) {
-            return source_move;
-        }
         if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
             return 0.0;
         }
@@ -82,9 +79,6 @@ public class AxisAlignedBB {
     }
 
     public static double collideY(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
-        if (target.isEmpty() || source.isEmpty()) {
-            return source_move;
-        }
         if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
             return 0.0;
         }
@@ -109,9 +103,6 @@ public class AxisAlignedBB {
     }
 
     public static double collideZ(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
-        if (target.isEmpty() || source.isEmpty()) {
-            return source_move;
-        }
         if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
             return 0.0;
         }
diff --git a/src/main/java/net/minecraft/server/ChunkCache.java b/src/main/java/net/minecraft/server/ChunkCache.java
index e95fc7d98b70c84f3bf94440da977deb2d541e46..ab1085091fefea3a3fa15f7028bec050d00a6f5e 100644
--- a/src/main/java/net/minecraft/server/ChunkCache.java
+++ b/src/main/java/net/minecraft/server/ChunkCache.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import java.util.List;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -15,23 +16,33 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
     // Tuinity start - optimise pathfinder collision detection
     @Override
     public boolean getCubes(Entity entity) {
-        return !this.collidesWithAnyBlockOrWorldBorder(entity, entity.getBoundingBox());
+        return !this.getCollisionsForBlocksOrWorldBorder(entity, entity.getBoundingBox(), null, true, null);
     }
 
     @Override
     public boolean getCubes(Entity entity, AxisAlignedBB axisalignedbb) {
-        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb);
+        return !this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, null, true, null);
     }
 
     @Override
     public boolean getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
-        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb);
+        return !this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, null, true, null);
     }
 
-    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+    public boolean getCollisionsForBlocksOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list,
+                                                    boolean collidesWithUnloaded,
+                                                    java.util.function.BiPredicate<IBlockData, BlockPosition> predicate) {
+        boolean ret = false;
+        final boolean checkOnly = true;
+
         if (entity != null) {
             if (this.getWorldBorder().isAlmostCollidingOnBorder(axisalignedbb)) {
-                return true;
+                if (checkOnly) {
+                    return true;
+                } else {
+                    VoxelShapes.addBoxesTo(this.getWorldBorder().getCollisionShape(), list);
+                    ret = true;
+                }
             }
         }
 
@@ -46,12 +57,12 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
 
 
         BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
+        VoxelShapeCollision collisionShape = null;
 
         // special cases:
         if (minBlockY > 255 || maxBlockY < 0) {
             // no point in checking
-            return false;
+            return ret;
         }
 
         int minYIterate = Math.max(0, minBlockY);
@@ -78,7 +89,15 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
                 Chunk chunk = (Chunk)this.getChunkIfLoaded(currChunkX, currChunkZ);
 
                 if (chunk == null) {
-                    return true;
+                    if (collidesWithUnloaded) {
+                        if (checkOnly) {
+                            return true;
+                        } else {
+                            list.add(AxisAlignedBB.getBoxForChunk(currChunkX, currChunkZ));
+                            ret = true;
+                        }
+                    }
+                    continue;
                 }
 
                 ChunkSection[] sections = chunk.getSections();
@@ -95,46 +114,42 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
                     }
 
                     DataPaletteBlock<IBlockData> blocks = section.blockIds;
-                    int blockKeyY = (currY & 15) << 8;
-
-                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
 
                     for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        int blockKeyZY = blockKeyY | (currZ << 4);
-                        int blockZ = currZ | chunkZGlobalPos; // world position
-
-                        int edgeCountZY;
-                        if (blockZ == minBlockZ || blockZ == maxBlockZ) {
-                            edgeCountZY = edgeCountY + 1;
-                        } else {
-                            edgeCountZY = edgeCountY;
-                        }
-
                         for (int currX = minX; currX <= maxX; ++currX) {
-                            int blockX = currX | chunkXGlobalPos; // world position
-
-                            int edgeCountFull;
-                            if (blockX == minBlockX || blockX == maxBlockX) {
-                                edgeCountFull = edgeCountZY + 1;
-                            } else {
-                                edgeCountFull = edgeCountZY;
-                            }
-
-                            if (edgeCountFull == 3) {
+                            int localBlockIndex = (currX) | (currZ << 4) | ((currY & 15) << 8);
+                            int blockX = currX | chunkXGlobalPos;
+                            int blockY = currY;
+                            int blockZ = currZ | chunkZGlobalPos;
+
+                            int edgeCount = ((blockX == minBlockX || blockX == maxBlockX) ? 1 : 0) +
+                                    ((blockY == minBlockY || blockY == maxBlockY) ? 1 : 0) +
+                                    ((blockZ == minBlockZ || blockZ == maxBlockZ) ? 1 : 0);
+                            if (edgeCount == 3) {
                                 continue;
                             }
 
-                            int blockKeyFull = blockKeyZY | currX;
-                            IBlockData blockData = blocks.rawGet(blockKeyFull);
+                            IBlockData blockData = blocks.rawGet(localBlockIndex);
 
-                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
-                                mutablePos.setValues(blockX, currY, blockZ);
+                            if ((edgeCount != 1 || blockData.shapeExceedsCube()) && (edgeCount != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
+                                mutablePos.setValues(blockX, blockY, blockZ);
+                                if (collisionShape == null) {
+                                    collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity);
+                                }
                                 VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
                                 if (voxelshape2 != VoxelShapes.getEmptyShape()) {
-                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
+                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)blockY, (double)blockZ);
+
+                                    if (predicate != null && !predicate.test(blockData, mutablePos)) {
+                                        continue;
+                                    }
 
-                                    if (voxelshape3.intersects(axisalignedbb)) {
-                                        return true;
+                                    if (checkOnly) {
+                                        if (voxelshape3.intersects(axisalignedbb)) {
+                                            return true;
+                                        }
+                                    } else {
+                                        ret |= VoxelShapes.addBoxesToIfIntersects(voxelshape3, axisalignedbb, list);
                                     }
                                 }
                             }
@@ -144,7 +159,7 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
             }
         }
 
-        return false;
+        return ret;
     }
     // Tuinity end - optimise pathfinder collision detection
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 097715bc66a2db4fdebcf8ed53aed459dfb43fa6..a125489d6a3b202d7e2b3d7df26fd72b81f2bd98 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -785,7 +785,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             }
 
             try {
-                this.checkBlockCollisions();
+                this.checkBlockCollisions(this.fireTicks <= 0); // Tuinity - move fire checking into method here
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
@@ -797,39 +797,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             float f2 = this.getBlockSpeedFactor();
 
             this.setMot(this.getMot().d((double) f2, 1.0D, (double) f2));
-            // Tuinity start - remove streams here
-            if (this.fireTicks <= 0) {
-                AxisAlignedBB boundingBox = this.getBoundingBox().shrink(0.001D);
-                BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-                int minX = MathHelper.floor(boundingBox.minX);
-                int minY = MathHelper.floor(boundingBox.minY);
-                int minZ = MathHelper.floor(boundingBox.minZ);
-                int maxX = MathHelper.floor(boundingBox.maxX);
-                int maxY = MathHelper.floor(boundingBox.maxY);
-                int maxZ = MathHelper.floor(boundingBox.maxZ);
-                boolean inFireLoaded = true;
-                boolean inFire = false;
-                fire_search:
-                for (int currY = minY; currY <= maxY; ++currY) {
-                    for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        for (int currX = minX; currX <= maxX; ++currX) {
-                            mutablePos.setValues(currX, currY, currZ);
-                            IBlockData type = this.getWorld().getTypeIfLoaded(mutablePos);
-                            if (type == null) {
-                                inFireLoaded = false;
-                                break fire_search;
-                            }
-                            if (!inFire && (type.a(TagsBlock.FIRE) || type.a(Blocks.LAVA))) {
-                                inFire = true;
-                            }
-                        }
-                    }
-                }
-                if (!inFire & inFireLoaded) {
-                    this.setFireTicks(-this.getMaxFireTicks());
-                }
-            }
-            // Tuinity end - remove streams here
+            // Tuinity - move into checkBlockCollisions
 
             if (this.aG() && this.isBurning()) {
                 this.playSound(SoundEffects.ENTITY_GENERIC_EXTINGUISH_FIRE, 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
@@ -1213,18 +1181,34 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
     }
 
     protected void checkBlockCollisions() {
+        // Tuinity start
+        this.checkBlockCollisions(false);
+    }
+    protected void checkBlockCollisions(boolean checkFire) {
+        boolean inFire = false;
+        // Tuinity end
         AxisAlignedBB axisalignedbb = this.getBoundingBox();
         BlockPosition blockposition = new BlockPosition(axisalignedbb.minX + 0.001D, axisalignedbb.minY + 0.001D, axisalignedbb.minZ + 0.001D);
         BlockPosition blockposition1 = new BlockPosition(axisalignedbb.maxX - 0.001D, axisalignedbb.maxY - 0.001D, axisalignedbb.maxZ - 0.001D);
         BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
 
         if (this.world.areChunksLoadedBetween(blockposition, blockposition1)) {
-            for (int i = blockposition.getX(); i <= blockposition1.getX(); ++i) {
-                for (int j = blockposition.getY(); j <= blockposition1.getY(); ++j) {
-                    for (int k = blockposition.getZ(); k <= blockposition1.getZ(); ++k) {
+            // Tuinity start - reorder iteration to more cache aware
+            for (int j = blockposition.getY(); j <= blockposition1.getY(); ++j) {
+                for (int k = blockposition.getZ(); k <= blockposition1.getZ(); ++k) {
+                    for (int i = blockposition.getX(); i <= blockposition1.getX(); ++i) {
+                        // Tuinity end - reorder iteration to more cache aware
                         blockposition_mutableblockposition.d(i, j, k);
                         IBlockData iblockdata = this.world.getType(blockposition_mutableblockposition);
 
+                        // Tuinity start - move fire checking in here - reuse getType from this method
+                        if (checkFire) {
+                            if (!inFire && (iblockdata.a(TagsBlock.FIRE) || iblockdata.a(Blocks.LAVA))) {
+                                inFire = true;
+                            }
+                        }
+                        // Tuinity end - move fire checking in here - reuse getType from this method
+
                         try {
                             iblockdata.a(this.world, blockposition_mutableblockposition, this);
                             this.a(iblockdata);
@@ -1238,6 +1222,11 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
                     }
                 }
             }
+            // Tuinity start - move fire checking in here - reuse getType from this method
+            if (checkFire & !inFire) {
+                this.setFireTicks(-this.getMaxFireTicks());
+            }
+            // Tuinity end - move fire checking in here - reuse getType from this method
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/ICollisionAccess.java b/src/main/java/net/minecraft/server/ICollisionAccess.java
index b66c802d5e27518069bf42e577bcc9a26c4d873e..cce0ac8a36bef3b9e5a2b95e0c3dd137e8525226 100644
--- a/src/main/java/net/minecraft/server/ICollisionAccess.java
+++ b/src/main/java/net/minecraft/server/ICollisionAccess.java
@@ -28,6 +28,11 @@ public interface ICollisionAccess extends IBlockAccess {
     }
 
     default boolean b(AxisAlignedBB axisalignedbb) {
+        // Tuinity start - allow overriding in WorldServer
+        return this.getCubes(axisalignedbb);
+    }
+    default boolean getCubes(AxisAlignedBB axisalignedbb) {
+        // Tuinity end - allow overriding in WorldServer
         return this.b((Entity) null, axisalignedbb, (entity) -> {
             return true;
         });
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index db735e29d427cc8f4bd4ba54c7a44daf9fed9e61..636bbbc42466cb54c300352f400464fe64cc2e79 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -36,12 +36,14 @@ public final class VoxelShapes {
     static final com.tuinity.tuinity.voxel.AABBVoxelShape optimisedFullCube = new com.tuinity.tuinity.voxel.AABBVoxelShape(new AxisAlignedBB(0, 0, 0, 1.0, 1.0, 1.0)); // Tuinity - optimise voxelshape
 
     // Tuinity start - optimise voxelshapes
-    public static void addBoxesToIfIntersects(VoxelShape shape, AxisAlignedBB aabb, java.util.List<AxisAlignedBB> list) {
+    public static boolean addBoxesToIfIntersects(VoxelShape shape, AxisAlignedBB aabb, java.util.List<AxisAlignedBB> list) {
         if (shape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape) {
             com.tuinity.tuinity.voxel.AABBVoxelShape shapeCasted = (com.tuinity.tuinity.voxel.AABBVoxelShape)shape;
-            if (shapeCasted.aabb.voxelShapeIntersect(aabb)) {
+            if (!shapeCasted.aabb.isEmpty() && shapeCasted.aabb.voxelShapeIntersect(aabb)) {
                 list.add(shapeCasted.aabb);
+                return true;
             }
+            return false;
         } else if (shape instanceof VoxelShapeArray) {
             VoxelShapeArray shapeCasted = (VoxelShapeArray)shape;
             // this can be optimised by checking an "overall shape" first, but not needed
@@ -50,39 +52,58 @@ public final class VoxelShapes {
             double offY = shapeCasted.offsetY;
             double offZ = shapeCasted.offsetZ;
 
+            boolean ret = false;
+
             for (AxisAlignedBB boundingBox : shapeCasted.boundingBoxesRepresentation) {
                 double minX, minY, minZ, maxX, maxY, maxZ;
                 if (aabb.voxelShapeIntersect(minX = boundingBox.minX + offX, minY = boundingBox.minY + offY, minZ = boundingBox.minZ + offZ,
                         maxX = boundingBox.maxX + offX, maxY = boundingBox.maxY + offY, maxZ = boundingBox.maxZ + offZ)) {
-                    list.add(new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ, false));
+                    AxisAlignedBB box = new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ, false);
+                    if (!box.isEmpty()) {
+                        list.add(box);
+                        ret = true;
+                    }
                 }
             }
+
+            return ret;
         } else {
+            boolean ret = false;
+
             java.util.List<AxisAlignedBB> boxes = shape.getBoundingBoxesRepresentation();
             for (int i = 0, len = boxes.size(); i < len; ++i) {
                 AxisAlignedBB box = boxes.get(i);
-                if (box.voxelShapeIntersect(aabb)) {
+                if (!box.isEmpty() && box.voxelShapeIntersect(aabb)) {
                     list.add(box);
+                    ret = true;
                 }
             }
+
+            return ret;
         }
     }
 
     public static void addBoxesTo(VoxelShape shape, java.util.List<AxisAlignedBB> list) {
         if (shape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape) {
             com.tuinity.tuinity.voxel.AABBVoxelShape shapeCasted = (com.tuinity.tuinity.voxel.AABBVoxelShape)shape;
-            list.add(shapeCasted.aabb);
+            if (!shapeCasted.isEmpty()) {
+                list.add(shapeCasted.aabb);
+            }
         } else if (shape instanceof VoxelShapeArray) {
             VoxelShapeArray shapeCasted = (VoxelShapeArray)shape;
 
             for (AxisAlignedBB boundingBox : shapeCasted.boundingBoxesRepresentation) {
-                list.add(boundingBox.offset(shapeCasted.offsetX, shapeCasted.offsetY, shapeCasted.offsetZ));
+                if (!boundingBox.isEmpty()) {
+                    list.add(boundingBox.offset(shapeCasted.offsetX, shapeCasted.offsetY, shapeCasted.offsetZ));
+                }
             }
         } else {
             java.util.List<AxisAlignedBB> boxes = shape.getBoundingBoxesRepresentation();
             for (int i = 0, len = boxes.size(); i < len; ++i) {
                 AxisAlignedBB box = boxes.get(i);
-                list.add(box);
+                if (!box.isEmpty()) {
+                    list.add(box);
+                }
             }
         }
     }
@@ -392,6 +413,49 @@ public final class VoxelShapes {
 
     public static boolean combinationOccludes(VoxelShape voxelshape, VoxelShape voxelshape1) { return b(voxelshape, voxelshape1); } // Tuinity - OBFHELPER
     public static boolean b(VoxelShape voxelshape, VoxelShape voxelshape1) {
+        if (voxelshape == getFullUnoptimisedCube() || voxelshape == optimisedFullCube
+                || voxelshape1 == getFullUnoptimisedCube() || voxelshape1 == optimisedFullCube) {
+            return true;
+        }
+        boolean v1Empty = voxelshape == getEmptyShape();
+        boolean v2Empty = voxelshape1 == getEmptyShape();
+        if (v1Empty && v2Empty) {
+            return false;
+        }
+        if ((voxelshape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape || v1Empty) && (voxelshape1 instanceof com.tuinity.tuinity.voxel.AABBVoxelShape || v2Empty)) {
+            if (!v1Empty && !v2Empty && (voxelshape != voxelshape1)) {
+                AxisAlignedBB boundingBox1 = ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape).aabb;
+                AxisAlignedBB boundingBox2 = ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape1).aabb;
+                // can call it here in some cases
+
+                // check overall bounding box
+                double minY = Math.min(boundingBox1.minY, boundingBox2.minY);
+                double maxY = Math.max(boundingBox1.maxY, boundingBox2.maxY);
+                if (minY > MCUtil.COLLISION_EPSILON || maxY < (1 - MCUtil.COLLISION_EPSILON)) {
+                    return false;
+                }
+                double minX = Math.min(boundingBox1.minX, boundingBox2.minX);
+                double maxX = Math.max(boundingBox1.maxX, boundingBox2.maxX);
+                if (minX > MCUtil.COLLISION_EPSILON || maxX < (1 - MCUtil.COLLISION_EPSILON)) {
+                    return false;
+                }
+                double minZ = Math.min(boundingBox1.minZ, boundingBox2.minZ);
+                double maxZ = Math.max(boundingBox1.maxZ, boundingBox2.maxZ);
+                if (minZ > MCUtil.COLLISION_EPSILON || maxZ < (1 - MCUtil.COLLISION_EPSILON)) {
+                    return false;
+                }
+                // fall through to full merge check
+            } else {
+                AxisAlignedBB boundingBox = v1Empty ? ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape1).aabb : ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape).aabb;
+                // check if the bounding box encloses the full cube
+                return (boundingBox.minY <= MCUtil.COLLISION_EPSILON && boundingBox.maxY >= (1 - MCUtil.COLLISION_EPSILON)) &&
+                       (boundingBox.minX <= MCUtil.COLLISION_EPSILON && boundingBox.maxX >= (1 - MCUtil.COLLISION_EPSILON)) &&
+                       (boundingBox.minZ <= MCUtil.COLLISION_EPSILON && boundingBox.maxZ >= (1 - MCUtil.COLLISION_EPSILON));
+            }
+        }
+        return b_rare(voxelshape, voxelshape1);
+    }
+    public static boolean b_rare(VoxelShape voxelshape, VoxelShape voxelshape1) {
         return (voxelshape != b() || voxelshape != getFullUnoptimisedCube()) && (voxelshape1 != b() || voxelshape1 != getFullUnoptimisedCube()) ? ((voxelshape == VoxelShapes.getEmptyShape() || voxelshape.isEmpty()) && (voxelshape1 == VoxelShapes.getEmptyShape() || voxelshape1.isEmpty()) ? false : !c(b(), b(voxelshape, voxelshape1, OperatorBoolean.OR), OperatorBoolean.ONLY_FIRST)) : true; // Tuinity - optimise call by checking against more constant shapes
     }
 
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 74bd9b253487aa7e1999e9a708cdbb194af1dcff..5c3080fd3e14988db9901c4e8015cf6da7af28a3 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -372,248 +372,15 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     }
 
     // Tuinity start - optimise collision
-    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks) {
-        if (entity != null) {
-            if (this.getWorldBorder().isAlmostCollidingOnBorder(axisalignedbb)) {
-                return true;
-            }
-        }
-
-        int minBlockX = MathHelper.floor(axisalignedbb.minX - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + MCUtil.COLLISION_EPSILON) + 1;
-
-        int minBlockY = MathHelper.floor(axisalignedbb.minY - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockY = MathHelper.floor(axisalignedbb.maxY + MCUtil.COLLISION_EPSILON) + 1;
-
-        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + MCUtil.COLLISION_EPSILON) + 1;
-
-
-        BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
-
-        // special cases:
-        if (minBlockY > 255 || maxBlockY < 0) {
-            // no point in checking
-            return false;
-        }
-
-        int minYIterate = Math.max(0, minBlockY);
-        int maxYIterate = Math.min(255, maxBlockY);
-
-        int minChunkX = minBlockX >> 4;
-        int maxChunkX = maxBlockX >> 4;
-
-        int minChunkZ = minBlockZ >> 4;
-        int maxChunkZ = maxBlockZ >> 4;
-
-        ChunkProviderServer chunkProvider = (ChunkProviderServer)this.chunkProvider;
-        // TODO special case single chunk?
-
-        for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
-            int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
-            int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 15; // coordinate in chunk
-
-            for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
-                int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
-                int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 15; // coordinate in chunk
-
-                int chunkXGlobalPos = currChunkX << 4;
-                int chunkZGlobalPos = currChunkZ << 4;
-                Chunk chunk = loadChunks ? chunkProvider.getChunkAt(currChunkX, currChunkZ, true) : chunkProvider.getChunkAtIfLoadedImmediately(currChunkX, currChunkZ);
-
-                if (chunk == null) {
-                    return true;
-                }
-
-                ChunkSection[] sections = chunk.getSections();
-
-                // bound y
-
-                for (int currY = minYIterate; currY <= maxYIterate; ++currY) {
-                    ChunkSection section = sections[currY >>> 4];
-                    if (section == null || section.isFullOfAir()) {
-                        // empty
-                        // skip to next section
-                        currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
-                        continue;
-                    }
-
-                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
-                    int blockKeyY = (currY & 15) << 8;
-
-                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
-
-                    for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        int blockKeyZY = blockKeyY | (currZ << 4);
-                        int blockZ = currZ | chunkZGlobalPos; // world position
-
-                        int edgeCountZY;
-                        if (blockZ == minBlockZ || blockZ == maxBlockZ) {
-                            edgeCountZY = edgeCountY + 1;
-                        } else {
-                            edgeCountZY = edgeCountY;
-                        }
-
-                        for (int currX = minX; currX <= maxX; ++currX) {
-                            int blockX = currX | chunkXGlobalPos; // world position
-
-                            int edgeCountFull;
-                            if (blockX == minBlockX || blockX == maxBlockX) {
-                                edgeCountFull = edgeCountZY + 1;
-                            } else {
-                                edgeCountFull = edgeCountZY;
-                            }
-
-                            if (edgeCountFull == 3) {
-                                continue;
-                            }
-
-                            int blockKeyFull = blockKeyZY | currX;
-                            IBlockData blockData = blocks.rawGet(blockKeyFull);
-
-                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
-                                mutablePos.setValues(blockX, currY, blockZ);
-                                VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
-                                if (voxelshape2 != VoxelShapes.getEmptyShape()) {
-                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
-
-                                    if (voxelshape3.intersects(axisalignedbb)) {
-                                        return true;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return false;
+    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks,
+                                                     boolean collidesWithUnloaded) {
+        return this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, null, loadChunks, collidesWithUnloaded, true, null);
     }
 
-    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks, boolean collideWithUnloaded, java.util.function.BiPredicate<IBlockData, BlockPosition> predicate) {
-        if (entity != null) {
-            if (this.getWorldBorder().isAlmostCollidingOnBorder(axisalignedbb)) {
-                return true;
-            }
-        }
-
-        int minBlockX = MathHelper.floor(axisalignedbb.minX - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + MCUtil.COLLISION_EPSILON) + 1;
-
-        int minBlockY = MathHelper.floor(axisalignedbb.minY - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockY = MathHelper.floor(axisalignedbb.maxY + MCUtil.COLLISION_EPSILON) + 1;
-
-        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + MCUtil.COLLISION_EPSILON) + 1;
-
-
-        BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
-
-        // special cases:
-        if (minBlockY > 255 || maxBlockY < 0) {
-            // no point in checking
-            return false;
-        }
-
-        int minYIterate = Math.max(0, minBlockY);
-        int maxYIterate = Math.min(255, maxBlockY);
-
-        int minChunkX = minBlockX >> 4;
-        int maxChunkX = maxBlockX >> 4;
-
-        int minChunkZ = minBlockZ >> 4;
-        int maxChunkZ = maxBlockZ >> 4;
-
-        ChunkProviderServer chunkProvider = (ChunkProviderServer)this.chunkProvider;
-        // TODO special case single chunk?
-
-        for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
-            int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
-            int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 15; // coordinate in chunk
-
-            for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
-                int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
-                int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 15; // coordinate in chunk
-
-                int chunkXGlobalPos = currChunkX << 4;
-                int chunkZGlobalPos = currChunkZ << 4;
-                Chunk chunk = loadChunks ? chunkProvider.getChunkAt(currChunkX, currChunkZ, true) : chunkProvider.getChunkAtIfLoadedImmediately(currChunkX, currChunkZ);
-
-                if (chunk == null) {
-                    if (collideWithUnloaded) {
-                        return true;
-                    } else {
-                        continue;
-                    }
-                }
-
-                ChunkSection[] sections = chunk.getSections();
-
-                // bound y
-
-                for (int currY = minYIterate; currY <= maxYIterate; ++currY) {
-                    ChunkSection section = sections[currY >>> 4];
-                    if (section == null || section.isFullOfAir()) {
-                        // empty
-                        // skip to next section
-                        currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
-                        continue;
-                    }
-
-                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
-                    int blockKeyY = (currY & 15) << 8;
-
-                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
-
-                    for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        int blockKeyZY = blockKeyY | (currZ << 4);
-                        int blockZ = currZ | chunkZGlobalPos; // world position
-
-                        int edgeCountZY;
-                        if (blockZ == minBlockZ || blockZ == maxBlockZ) {
-                            edgeCountZY = edgeCountY + 1;
-                        } else {
-                            edgeCountZY = edgeCountY;
-                        }
-
-                        for (int currX = minX; currX <= maxX; ++currX) {
-                            int blockX = currX | chunkXGlobalPos; // world position
-
-                            int edgeCountFull;
-                            if (blockX == minBlockX || blockX == maxBlockX) {
-                                edgeCountFull = edgeCountZY + 1;
-                            } else {
-                                edgeCountFull = edgeCountZY;
-                            }
-
-                            if (edgeCountFull == 3) {
-                                continue;
-                            }
-
-                            int blockKeyFull = blockKeyZY | currX;
-                            IBlockData blockData = blocks.rawGet(blockKeyFull);
-
-                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
-                                mutablePos.setValues(blockX, currY, blockZ);
-                                VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
-                                if (voxelshape2 != VoxelShapes.getEmptyShape()) {
-                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
-
-                                    if (voxelshape3.intersects(axisalignedbb) && (predicate == null || predicate.test(blockData, mutablePos))) {
-                                        return true;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return false;
+    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb,
+                                                     boolean loadChunks, boolean collidesWithUnloaded,
+                                                     java.util.function.BiPredicate<IBlockData, BlockPosition> predicate) {
+        return this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, null, loadChunks, collidesWithUnloaded, true, predicate);
     }
 
     public final boolean hardCollidesWithAnyEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<Entity> predicate) {
@@ -648,13 +415,24 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     }
 
     public final boolean hasAnyCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks) {
-        return this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, loadChunks) || this.hardCollidesWithAnyEntities(entity, axisalignedbb, null);
+        return this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, loadChunks, true)
+                || this.hardCollidesWithAnyEntities(entity, axisalignedbb, null);
     }
 
-    public void getCollisionsForBlocksOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, boolean loadChunks) {
+    // returns whether any collisions were detected
+    public boolean getCollisionsForBlocksOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list,
+                                                    boolean loadChunks, boolean collidesWithUnloaded, boolean checkOnly,
+                                                    java.util.function.BiPredicate<IBlockData, BlockPosition> predicate) {
+        boolean ret = false;
+
         if (entity != null) {
             if (this.getWorldBorder().isAlmostCollidingOnBorder(axisalignedbb)) {
-                VoxelShapes.addBoxesTo(this.getWorldBorder().getCollisionShape(), list);
+                if (checkOnly) {
+                    return true;
+                } else {
+                    VoxelShapes.addBoxesTo(this.getWorldBorder().getCollisionShape(), list);
+                    ret = true;
+                }
             }
         }
 
@@ -669,12 +447,12 @@ public class WorldServer extends World implements GeneratorAccessSeed {
 
 
         BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
+        VoxelShapeCollision collisionShape = null;
 
         // special cases:
         if (minBlockY > 255 || maxBlockY < 0) {
             // no point in checking
-            return;
+            return ret;
         }
 
         int minYIterate = Math.max(0, minBlockY);
@@ -702,7 +480,14 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                 Chunk chunk = loadChunks ? chunkProvider.getChunkAt(currChunkX, currChunkZ, true) : chunkProvider.getChunkAtIfLoadedImmediately(currChunkX, currChunkZ);
 
                 if (chunk == null) {
-                    list.add(AxisAlignedBB.getBoxForChunk(currChunkX, currChunkZ));
+                    if (collidesWithUnloaded) {
+                        if (checkOnly) {
+                            return true;
+                        } else {
+                            list.add(AxisAlignedBB.getBoxForChunk(currChunkX, currChunkZ));
+                            ret = true;
+                        }
+                    }
                     continue;
                 }
 
@@ -720,45 +505,43 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                     }
 
                     DataPaletteBlock<IBlockData> blocks = section.blockIds;
-                    int blockKeyY = (currY & 15) << 8;
-
-                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
 
                     for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        int blockKeyZY = blockKeyY | (currZ << 4);
-                        int blockZ = currZ | chunkZGlobalPos; // world position
-
-                        int edgeCountZY;
-                        if (blockZ == minBlockZ || blockZ == maxBlockZ) {
-                            edgeCountZY = edgeCountY + 1;
-                        } else {
-                            edgeCountZY = edgeCountY;
-                        }
-
                         for (int currX = minX; currX <= maxX; ++currX) {
-                            int blockX = currX | chunkXGlobalPos; // world position
-
-                            int edgeCountFull;
-                            if (blockX == minBlockX || blockX == maxBlockX) {
-                                edgeCountFull = edgeCountZY + 1;
-                            } else {
-                                edgeCountFull = edgeCountZY;
-                            }
-
-                            if (edgeCountFull == 3) {
+                            int localBlockIndex = (currX) | (currZ << 4) | ((currY & 15) << 8);
+                            int blockX = currX | chunkXGlobalPos;
+                            int blockY = currY;
+                            int blockZ = currZ | chunkZGlobalPos;
+
+                            int edgeCount = ((blockX == minBlockX || blockX == maxBlockX) ? 1 : 0) +
+                                    ((blockY == minBlockY || blockY == maxBlockY) ? 1 : 0) +
+                                    ((blockZ == minBlockZ || blockZ == maxBlockZ) ? 1 : 0);
+                            if (edgeCount == 3) {
                                 continue;
                             }
 
-                            int blockKeyFull = blockKeyZY | currX;
-                            IBlockData blockData = blocks.rawGet(blockKeyFull);
+                            IBlockData blockData = blocks.rawGet(localBlockIndex);
 
-                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
-                                mutablePos.setValues(blockX, currY, blockZ);
+                            if ((edgeCount != 1 || blockData.shapeExceedsCube()) && (edgeCount != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
+                                mutablePos.setValues(blockX, blockY, blockZ);
+                                if (collisionShape == null) {
+                                    collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity);
+                                }
                                 VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
                                 if (voxelshape2 != VoxelShapes.getEmptyShape()) {
-                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
+                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)blockY, (double)blockZ);
 
-                                    VoxelShapes.addBoxesToIfIntersects(voxelshape3, axisalignedbb, list);
+                                    if (predicate != null && !predicate.test(blockData, mutablePos)) {
+                                        continue;
+                                    }
+
+                                    if (checkOnly) {
+                                        if (voxelshape3.intersects(axisalignedbb)) {
+                                            return true;
+                                        }
+                                    } else {
+                                        ret |= VoxelShapes.addBoxesToIfIntersects(voxelshape3, axisalignedbb, list);
+                                    }
                                 }
                             }
                         }
@@ -766,6 +549,8 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                 }
             }
         }
+
+        return ret;
     }
 
     public final void getEntityHardCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<Entity> predicate, List<AxisAlignedBB> list) {
@@ -785,7 +570,9 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                 Entity otherEntity = entities.get(i);
 
                 if ((entity == null || otherEntity.collisionBoxIsHard()) || entity.hardCollidesWith(otherEntity)) {
-                    list.add(otherEntity.getBoundingBox());
+                    if (!otherEntity.getBoundingBox().isEmpty()) {
+                        list.add(otherEntity.getBoundingBox());
+                    }
                 }
             }
         } finally {
@@ -794,10 +581,15 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     }
 
     public final void getCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, boolean loadChunks) {
-        this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, list, loadChunks);
+        this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, list, loadChunks, true, false, null);
         this.getEntityHardCollisions(entity, axisalignedbb, null, list);
     }
 
+    @Override
+    public boolean getCubes(AxisAlignedBB axisalignedbb) {
+        return !this.hasAnyCollisions(null, axisalignedbb);
+    }
+
     @Override
     public boolean getCubes(Entity entity) {
         return !this.hasAnyCollisions(entity, entity.getBoundingBox());
@@ -812,7 +604,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     @Override
     public boolean getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
         if (entity instanceof EntityArmorStand && !entity.world.paperConfig.armorStandEntityLookups) return false;
-        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, true) && !this.hardCollidesWithAnyEntities(entity, axisalignedbb, predicate);
+        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, true, true) && !this.hardCollidesWithAnyEntities(entity, axisalignedbb, predicate);
     }
     // Tuinity end - optimise collision
 
